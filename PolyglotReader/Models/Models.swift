import Foundation
import Combine
import CoreGraphics

// MARK: - Annotation Stats
struct AnnotationStats: Codable {
    var total: Int = 0
    var highlights: Int = 0
    var notes: Int = 0
    var aiNotes: Int = 0
    var favorites: Int = 0
    var colorCounts: [String: Int] = [:]

    var yellowCount: Int { colorCounts["#fef08a"] ?? 0 }
    var greenCount: Int { colorCounts["#bbf7d0"] ?? 0 }
    var blueCount: Int { colorCounts["#bae6fd"] ?? 0 }
    var pinkCount: Int { colorCounts["#fbcfe8"] ?? 0 }
}

// MARK: - User Model
struct User: Codable, Identifiable {
    let id: String
    var name: String
    var email: String
    var avatarURL: URL?

    init(id: String, name: String, email: String, avatarURL: URL? = nil) {
        self.id = id
        self.name = name
        self.email = email
        self.avatarURL = avatarURL
    }
}

// MARK: - User Preferences
struct UserPreferences: Codable {
    var theme: ThemeMode = .system
    var autoSummary: Bool = true
    var defaultLanguage: String = "tr"
    var enableNotifications: Bool = true

    enum ThemeMode: String, Codable, CaseIterable {
        case light, dark, system

        var displayName: String {
            switch self {
            case .light: return "Açık"
            case .dark: return "Koyu"
            case .system: return "Sistem"
            }
        }
    }
}

// MARK: - Folder Model
struct Folder: Codable, Identifiable, Hashable {
    let id: UUID
    var name: String
    var color: String           // Hex renk kodu
    var parentId: UUID?         // İç içe klasörler için (opsiyonel)
    var userId: String
    var createdAt: Date
    var fileCount: Int

    var sfSymbol: String {
        "folder.fill"
    }

    init(
        id: UUID = UUID(),
        name: String,
        color: String = "#6366F1",
        parentId: UUID? = nil,
        userId: String,
        createdAt: Date = Date(),
        fileCount: Int = 0
    ) {
        self.id = id
        self.name = name
        self.color = color
        self.parentId = parentId
        self.userId = userId
        self.createdAt = createdAt
        self.fileCount = fileCount
    }
}

// MARK: - Tag Model
struct Tag: Codable, Identifiable, Hashable {
    let id: UUID
    var name: String
    var color: String           // Hex renk kodu
    var userId: String
    var createdAt: Date
    var fileCount: Int
    var isAutoGenerated: Bool

    init(
        id: UUID = UUID(),
        name: String,
        color: String = "#22C55E",
        userId: String,
        createdAt: Date = Date(),
        fileCount: Int = 0,
        isAutoGenerated: Bool = true
    ) {
        self.id = id
        self.name = name
        self.color = color
        self.userId = userId
        self.createdAt = createdAt
        self.fileCount = fileCount
        self.isAutoGenerated = isAutoGenerated
    }
}

// MARK: - PDF Document Metadata
struct PDFDocumentMetadata: Codable, Identifiable {
    let id: String
    var name: String
    var size: Int
    var uploadedAt: Date
    var storagePath: String
    var thumbnailData: Data?
    var summary: String?

    // Klasör ve Etiket Sistemi
    var folderId: UUID?
    var tags: [Tag]
    var aiCategory: String?

    var formattedSize: String {
        let formatter = ByteCountFormatter()
        formatter.allowedUnits = [.useKB, .useMB, .useGB]
        formatter.countStyle = .file
        return formatter.string(fromByteCount: Int64(size))
    }

    var formattedDate: String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.locale = Locale(identifier: "tr_TR")
        return formatter.string(from: uploadedAt)
    }

    init(
        id: String,
        name: String,
        size: Int,
        uploadedAt: Date,
        storagePath: String,
        thumbnailData: Data? = nil,
        summary: String? = nil,
        folderId: UUID? = nil,
        tags: [Tag] = [],
        aiCategory: String? = nil
    ) {
        self.id = id
        self.name = name
        self.size = size
        self.uploadedAt = uploadedAt
        self.storagePath = storagePath
        self.thumbnailData = thumbnailData
        self.summary = summary
        self.folderId = folderId
        self.tags = tags
        self.aiCategory = aiCategory
    }
}

// MARK: - Annotation
enum AnnotationType: String, Codable {
    case highlight
    case underline
    case strikethrough
}

struct AnnotationRect: Codable {
    var x: CGFloat  // Percentage (0-100)
    var y: CGFloat
    var width: CGFloat
    var height: CGFloat

    /// CGFloat değerini güvenli hale getirir (NaN, Infinity → 0)
    private static func sanitize(_ value: CGFloat) -> CGFloat {
        guard value.isFinite else { return 0 }
        return value
    }

    /// Geçerli bir rect mi kontrol eder
    var isValid: Bool {
        x.isFinite && y.isFinite && width.isFinite && height.isFinite &&
        width > 0 && height > 0
    }

    /// Debug amaçlı validasyon raporu
    var validationReport: String {
        var issues: [String] = []
        if !x.isFinite { issues.append("x=\(x)") }
        if !y.isFinite { issues.append("y=\(y)") }
        if !width.isFinite { issues.append("width=\(width)") }
        if !height.isFinite { issues.append("height=\(height)") }
        if width <= 0 { issues.append("width<=0") }
        if height <= 0 { issues.append("height<=0") }

        return issues.isEmpty ? "✅ Valid" : "❌ Issues: \(issues.joined(separator: ", "))"
    }

    // Custom Codable - NaN/Infinity değerlerini 0'a çevir
    enum CodingKeys: String, CodingKey {
        case x, y, width, height
    }

    init(x: CGFloat, y: CGFloat, width: CGFloat, height: CGFloat) {
        self.x = Self.sanitize(x)
        self.y = Self.sanitize(y)
        self.width = Self.sanitize(width)
        self.height = Self.sanitize(height)
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        x = Self.sanitize(try container.decode(CGFloat.self, forKey: .x))
        y = Self.sanitize(try container.decode(CGFloat.self, forKey: .y))
        width = Self.sanitize(try container.decode(CGFloat.self, forKey: .width))
        height = Self.sanitize(try container.decode(CGFloat.self, forKey: .height))
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(Self.sanitize(x), forKey: .x)
        try container.encode(Self.sanitize(y), forKey: .y)
        try container.encode(Self.sanitize(width), forKey: .width)
        try container.encode(Self.sanitize(height), forKey: .height)
    }
}

struct Annotation: Codable, Identifiable {
    let id: String
    var fileId: String
    var pageNumber: Int
    var type: AnnotationType
    var color: String  // Hex color
    var rects: [AnnotationRect]
    var text: String?
    var note: String?
    var isAiGenerated: Bool
    var createdAt: Date
    var updatedAt: Date?

    init(
        id: String = UUID().uuidString,
        fileId: String,
        pageNumber: Int,
        type: AnnotationType,
        color: String,
        rects: [AnnotationRect],
        text: String? = nil,
        note: String? = nil,
        isAiGenerated: Bool = false,
        createdAt: Date = Date(),
        updatedAt: Date? = nil
    ) {
        self.id = id
        self.fileId = fileId
        self.pageNumber = pageNumber
        self.type = type
        self.color = color
        self.rects = rects
        self.text = text
        self.note = note
        self.isAiGenerated = isAiGenerated
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }
}

// MARK: - Annotation JSON Safety Extension
extension Annotation {
    /// Returns a deep copy with all String properties safely re-allocated
    /// Prevents EXC_BAD_ACCESS from corrupted string backing storage during async operations
    /// CRITICAL: Uses JSON encode/decode to safely read all properties without direct access
    var safeForJSON: Annotation {
        // Property'lere direkt erişim crash'e neden oluyor
        // JSON encode/decode kullanarak tüm property'leri güvenli bir şekilde oku
        let encoder = JSONEncoder()
        let decoder = JSONDecoder()

        // Annotation'ı JSON'a encode et (property'lere güvenli erişim)
        guard let jsonData = try? encoder.encode(self),
              let decoded = try? decoder.decode(Annotation.self, from: jsonData) else {
            // Encode/decode başarısız olursa, fallback annotation oluştur
            return Annotation(
                id: UUID().uuidString,
                fileId: UUID().uuidString,
                pageNumber: 1,
                type: .highlight,
                color: "#fef08a",
                rects: [],
                text: nil,
                note: nil,
                isAiGenerated: false,
                createdAt: Date(),
                updatedAt: nil
            )
        }

        // Decoded annotation'ın tüm String property'lerini Data'ya çevirip tekrar String'e çevir
        // Bu, yeni memory allocation sağlar
        func safeString(_ str: String, fallback: String = "") -> String {
            guard let data = str.data(using: .utf8),
                  let safeStr = String(data: data, encoding: .utf8) else {
                return fallback
            }
            return safeStr
        }

        let colorValue = safeString(decoded.color, fallback: "#fef08a")
        let resolvedColor = colorValue.isEmpty ? "#fef08a" : colorValue

        return Annotation(
            id: safeString(decoded.id, fallback: UUID().uuidString),
            fileId: safeString(decoded.fileId, fallback: UUID().uuidString),
            pageNumber: decoded.pageNumber,
            type: decoded.type,
            color: resolvedColor,
            rects: decoded.rects,
            text: decoded.text.map { safeString($0, fallback: "") }.flatMap { $0.isEmpty ? nil : $0 },
            note: decoded.note.map { safeString($0, fallback: "") }.flatMap { $0.isEmpty ? nil : $0 },
            isAiGenerated: decoded.isAiGenerated,
            createdAt: decoded.createdAt,
            updatedAt: decoded.updatedAt
        )
    }
}

// MARK: - Chat Message
struct ChatMessage: Codable, Identifiable {
    let id: String
    var role: MessageRole
    var text: String
    var timestamp: Date

    enum MessageRole: String, Codable {
        case user
        case model
    }

    init(id: String = UUID().uuidString, role: MessageRole, text: String, timestamp: Date = Date()) {
        self.id = id
        self.role = role
        self.text = text
        self.timestamp = timestamp
    }
}

// MARK: - Quiz
struct QuizQuestion: Codable, Identifiable {
    let id: Int
    var question: String
    var options: [String]
    var correctAnswerIndex: Int
    var explanation: String?
}

// MARK: - Translation Result
struct TranslationResult: Codable {
    var original: String
    var translated: String
    var detectedLanguage: String
}

// MARK: - Selection Data
struct SelectionData {
    var text: String
    var rect: CGRect
    var pageNumber: Int
}
