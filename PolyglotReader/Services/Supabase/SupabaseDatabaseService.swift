import Foundation
import Supabase
import PostgREST

// MARK: - Database Service

/// Handles database operations for annotations, chats, and other data
@MainActor
final class SupabaseDatabaseService {
    // MARK: - Properties

    private let client: SupabaseClient

    // MARK: - Initialization

    init(client: SupabaseClient) {
        self.client = client
    }

    // MARK: - Chat Operations

    func saveChat(fileId: String, userId: String, role: String, content: String) async throws {
        struct ChatInsert: Encodable {
            let file_id: String
            let user_id: String
            let role: String
            let content: String
        }

        try await client
            .from("chats")
            .insert(ChatInsert(
                file_id: fileId,
                user_id: userId,
                role: role,
                content: content
            ))
            .execute()
    }

    func getChats(fileId: String) async throws -> [ChatMessage] {
        struct ChatRecord: Decodable {
            let id: String
            let file_id: String
            let role: String
            let content: String
            let created_at: String
        }

        let records: [ChatRecord] = try await client
            .from("chats")
            .select()
            .eq("file_id", value: fileId)
            .order("created_at", ascending: true)
            .execute()
            .value

        return records.map { record in
            ChatMessage(
                id: record.id,
                role: mapRole(record.role),
                text: record.content,
                timestamp: DateFormatting.date(from: record.created_at)
            )
        }
    }

    func deleteChats(fileId: String) async throws {
        try await client
            .from("chats")
            .delete()
            .eq("file_id", value: fileId)
            .execute()
    }

    // MARK: - Tag Operations

    func listTags(userId: String) async throws -> [Tag] {
        struct TagRecord: Decodable {
            let id: UUID
            let name: String
            let user_id: String
            let created_at: String
            let file_count: Int?
        }

        let records: [TagRecord] = try await client
            .from("tags")
            .select()
            .eq("user_id", value: userId)
            .order("name", ascending: true)
            .execute()
            .value

        return records.map {
            Tag(
                id: $0.id,
                name: $0.name,
                userId: $0.user_id,
                createdAt: DateFormatting.date(from: $0.created_at),
                fileCount: $0.file_count ?? 0,
                isAutoGenerated: false // Default to false or fetch if column exists
            )
        }
    }

    func getFileTags(fileId: String) async throws -> [Tag] {
        struct TagRecord: Decodable {
            let id: UUID
            let name: String
            let user_id: String
            let created_at: String
            let file_count: Int?
        }

        struct FileTagResponse: Decodable {
            let tags: TagRecord?
            // Note: Supabase likely returns inner object. If relationship is correct.
        }

        // It's safer to fetch tags directly via join if possible or just map properly
        // Let's assume standard Supabase join behavior: select("tags(*)")

        // Alternative: decode directly to Tag if Tag matches JSON?
        // Tag struct has userId, but JSON has snake_case 'user_id'.
        // Tag is Codable. But strictly?

        // Let's stick to explicit mapping for safety
        let response: [FileTagResponse] = try await client
            .from("file_tags")
            .select("tags(*)")
            .eq("file_id", value: fileId)
            .execute()
            .value

        return response.compactMap { $0.tags }.map {
            Tag(
                id: $0.id,
                name: $0.name,
                userId: $0.user_id,
                createdAt: DateFormatting.date(from: $0.created_at),
                fileCount: $0.file_count ?? 0,
                isAutoGenerated: false
            )
        }
    }

    /// Batch load tags for multiple files in a single query
    /// This fixes the N+1 problem where each file requires a separate query
    func getFileTagsBatch(fileIds: [String]) async throws -> [String: [Tag]] {
        guard !fileIds.isEmpty else { return [:] }
        
        struct TagRecord: Decodable {
            let id: UUID
            let name: String
            let user_id: String
            let created_at: String
            let file_count: Int?
            let color: String?
            let is_auto_generated: Bool?
        }

        struct FileTagResponse: Decodable {
            let file_id: String
            let tags: TagRecord?
        }

        // Single query to get all tags for all files
        let response: [FileTagResponse] = try await client
            .from("file_tags")
            .select("file_id, tags(*)")
            .in("file_id", values: fileIds)
            .execute()
            .value

        // Group tags by file_id
        var result: [String: [Tag]] = [:]
        
        // Initialize empty arrays for all file IDs
        for fileId in fileIds {
            result[fileId] = []
        }
        
        // Map and group the results
        for item in response {
            if let tagRecord = item.tags {
                let tag = Tag(
                    id: tagRecord.id,
                    name: tagRecord.name,
                    color: tagRecord.color ?? "#6366F1",
                    userId: tagRecord.user_id,
                    createdAt: DateFormatting.date(from: tagRecord.created_at),
                    fileCount: tagRecord.file_count ?? 0,
                    isAutoGenerated: tagRecord.is_auto_generated ?? false
                )
                result[item.file_id, default: []].append(tag)
            }
        }
        
        logInfo("SupabaseDatabaseService", "Batch tag yükleme tamamlandı", 
                details: "\(fileIds.count) dosya, \(response.count) etiket ilişkisi")
        
        return result
    }

    func getOrCreateTag(name: String, userId: String) async throws -> Tag {
        // First try to find existing tag
        struct TagResponse: Decodable {
            let id: UUID
            let name: String
            let user_id: String
            let file_count: Int?  // Optional because tags table may not include this computed field
        }

        let existing: [TagResponse] = try await client
            .from("tags")
            .select()
            .ilike("name", pattern: name)
            .eq("user_id", value: userId)
            .execute()
            .value

        if let first = existing.first {
             return Tag(id: first.id, name: first.name, userId: first.user_id, fileCount: first.file_count ?? 0)
        }

        // Create new tag
        struct TagInsert: Encodable {
            let name: String
            let user_id: String
        }

        let newTag: TagResponse = try await client
            .from("tags")
            .insert(TagInsert(name: name, user_id: userId))
            .select()
            .single()
            .execute()
            .value

        return Tag(id: newTag.id, name: newTag.name, userId: newTag.user_id, fileCount: newTag.file_count ?? 0)
    }

    func addTagsToFile(fileId: String, tagIds: [UUID]) async throws {
        struct FileTagInsert: Encodable {
            let file_id: String
            let tag_id: UUID
        }

        let inserts = tagIds.map { FileTagInsert(file_id: fileId, tag_id: $0) }

        try await client
            .from("file_tags")
            .upsert(inserts)
            .execute()
    }

    // MARK: - Image Metadata Operations

    func getImageMetadata(fileId: String) async throws -> [PDFImageMetadata] {
        let records: [PDFImageMetadata] = try await client
            .from("image_metadata")
            .select()
            .eq("file_id", value: fileId)
            .execute()
            .value
        return records
    }

    func saveImageMetadata(_ metadata: PDFImageMetadata) async throws {
        try await client
            .from("image_metadata")
            .upsert(metadata)
            .execute()
    }

    func saveImageMetadata(_ metadata: [PDFImageMetadata]) async throws {
        try await client
            .from("image_metadata")
            .upsert(metadata)
            .execute()
    }

    func updateImageCaption(imageId: String, caption: String, embedding: [Float]? = nil) async throws {
        struct CaptionUpdate: Encodable {
            let caption: String
            let embedding: [Float]?
        }
         var data: [String: AnyJSON] = ["caption": AnyJSON.string(caption)]
         if let embedding = embedding {
             data["caption_embedding"] = AnyJSON.array(embedding.map { .double(Double($0)) })
         }

         try await client
             .from("image_metadata")
             .update(data)
             .eq("id", value: imageId)
             .execute()
    }

    // MARK: - RAG Operations

    struct DocumentChunkRecord: Encodable {
        let content: String
        let embedding: [Float]
        let file_id: String
        let page_number: Int?
        let chunk_index: Int
    }

    func saveDocumentChunks(
        fileId: String,
        chunks: [(content: String, embedding: [Float], pageNumber: Int?)]
    ) async throws {
        // First, delete existing chunks for this file to avoid duplicates
        struct ReindexResult: Decodable {
            // The function returns an integer (deleted count)
        }

        do {
            // Call reindex_document to clear old chunks
            let _: Int = try await client
                .rpc("reindex_document", params: ["p_file_id": fileId])
                .execute()
                .value
        } catch {
            // If reindex fails, log but continue (might be first indexing)
            logWarning(
                "SupabaseDatabaseService",
                "Reindex failed, continuing with insert",
                details: error.localizedDescription
            )
        }

        // Now insert all chunks - using batch insert for performance
        let records = chunks.enumerated().map { index, chunk in
            DocumentChunkRecord(
                content: chunk.content,
                embedding: chunk.embedding,
                file_id: fileId,
                page_number: chunk.pageNumber,
                chunk_index: index
            )
        }

        try await client
            .from("document_chunks")
            .insert(records)
            .execute()
    }

    func fetchChunkSlice(
        fileId: String,
        offset: Int,
        limit: Int,
        ascending: Bool
    ) async throws -> [SupabaseChunkSlice] {
        guard limit > 0 else { return [] }

        let start = max(0, offset)
        let end = max(start, start + limit - 1)

        let records: [SupabaseChunkSlice] = try await client
            .from("document_chunks")
            .select("id, content, page_number, chunk_index")
            .eq("file_id", value: fileId)
            .order("chunk_index", ascending: ascending)
            .range(from: start, to: end)
            .execute()
            .value

        return records
    }

    // MARK: - Image Captions

    func searchImageCaptions(query: String, fileId: String) async throws -> [PDFImageMetadata] {
        // Text search implementation needed or rely on embedding search
        // For now returning empty or implementing basic text match if needed
        []
    }

    func searchImageCaptions(
        embedding: [Float],
        fileId: String,
        limit: Int = 5,
        threshold: Float = 0.5
    ) async throws -> [PDFImageMetadata] {
        // Assuming RPC 'match_image_captions' exists
        let records: [PDFImageMetadata] = try await client
            .rpc("match_image_captions", params: SupabaseImageSearchParams(
                file_id: fileId,
                query_embedding: embedding,
                match_threshold: threshold,
                match_count: limit
            ))
            .execute()
            .value

        return records
    }

    func cleanupUnusedTags() async throws {
        // Calling a stored procedure is safer if authorized,
        // or execute a delete query for tags with 0 file_tags.
        // Assuming 'cleanup_unused_tags' RPC exists or we do it manually.
        // Manual:
        // Delete tags where id not in (select tag_id from file_tags)
        // This is hard via standard client without raw query or rpc.
        // Check if RPC exists.

        // For now, assume rpc:
        try await client.rpc("cleanup_unused_tags").execute()
    }

    // MARK: - Folder Operations

    func getFolders(userId: String, parentId: UUID? = nil) async throws -> [Folder] {
        struct FolderRecord: Decodable {
            let id: String
            let name: String
            let color: String?
            let created_at: String
            let parent_id: String?
        }

        var query = client
            .from("folders")
            .select()
            .eq("user_id", value: userId)

        if let parentId = parentId {
            query = query.eq("parent_id", value: parentId.uuidString)
        } else {
            // Filter for null parent_id (root folders)
            // Filter for null parent_id (root folders)
            // Using match with AnyJSON.null
            query = query.is("parent_id", value: nil)
        }

        let records: [FolderRecord] = try await query
            .order("name", ascending: true)
            .execute()
            .value

        return records.compactMap { record in
            guard let uuid = UUID(uuidString: record.id) else { return nil }
            return Folder(
                id: uuid,
                name: record.name,
                color: record.color ?? "#6366F1",
                parentId: record.parent_id.flatMap { UUID(uuidString: $0) },
                userId: userId
            )
        }
    }

    func createFolder(name: String, userId: String, color: String?, parentId: UUID? = nil) async throws -> Folder {
        struct FolderInsert: Encodable {
            let name: String
            let user_id: String
            let color: String?
            let parent_id: UUID?
        }

        struct FolderResponse: Decodable {
            let id: String
            let name: String
            let color: String?
            let parent_id: String?
        }

        // Ensure parentId exists if provided (optional validation step, or rely on FK constraint)

        let response: FolderResponse = try await client
            .from("folders")
            .insert(FolderInsert(
                name: name,
                user_id: userId,
                color: color,
                parent_id: parentId
            ))
            .select()
            .single()
            .execute()
            .value

        guard let uuid = UUID(uuidString: response.id) else {
            let error = NSError(
                domain: "SupabaseDatabaseService",
                code: -1,
                userInfo: [NSLocalizedDescriptionKey: "Invalid UUID from server"]
            )
            throw error
        }

        return Folder(
            id: uuid,
            name: response.name,
            color: response.color ?? "#6366F1",
            userId: userId
        )
    }

    func deleteFolder(id: String) async throws {
        try await client
            .from("folders")
            .delete()
            .eq("id", value: id)
            .execute()
    }

    // MARK: - Reading Progress

    func getReadingProgress(fileId: String, userId: String) async throws -> ReadingProgress? {
        let results: [ReadingProgress] = try await client
            .from("reading_progress")
            .select()
            .eq("file_id", value: fileId)
            .eq("user_id", value: userId)
            .limit(1)
            .execute()
            .value

        return results.first
    }

    func saveReadingProgress(
        fileId: String,
        userId: String,
        page: Int,
        offsetX: Double,
        offsetY: Double,
        scale: Double
    ) async throws {
        struct ReadingProgressInsert: Encodable {
            let user_id: String
            let file_id: String
            let page: Int
            let offset_x: Double
            let offset_y: Double
            let zoom_scale: Double
        }

        let data = ReadingProgressInsert(
            user_id: userId,
            file_id: fileId,
            page: page,
            offset_x: offsetX,
            offset_y: offsetY,
            zoom_scale: scale
        )

        try await client
            .from("reading_progress")
            .upsert(data, onConflict: "user_id,file_id")
            .execute()
    }

    // MARK: - Private Helpers

    private func mapRole(_ role: String) -> ChatMessage.MessageRole {
        switch role.lowercased() {
        case "user":
            return .user
        case "assistant", "model":
            return .model
        case "system":
            // ChatMessage.MessageRole currently only supports user/model
            // Fallback to model for system messages in this UI context
            return .model
        default:
            return .model
        }
    }
}

// End of file cleanup
