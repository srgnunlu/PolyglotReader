'use client';

import { useState, useEffect, useCallback } from 'react';
import { getSupabase } from '@/lib/supabase';
import { PDFDocumentMetadata, Folder, Tag, DatabaseFileRecord, DatabaseFolder, DatabaseTag } from '@/types/models';

interface UseDocumentsReturn {
    documents: PDFDocumentMetadata[];
    folders: Folder[];
    tags: Tag[];
    isLoading: boolean;
    error: string | null;
    selectedFolder: string | null;
    selectedTag: string | null;
    searchQuery: string;
    setSelectedFolder: (id: string | null) => void;
    setSelectedTag: (id: string | null) => void;
    setSearchQuery: (query: string) => void;
    refresh: () => Promise<void>;
}

export function useDocuments(): UseDocumentsReturn {
    const [documents, setDocuments] = useState<PDFDocumentMetadata[]>([]);
    const [folders, setFolders] = useState<Folder[]>([]);
    const [tags, setTags] = useState<Tag[]>([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [selectedFolder, setSelectedFolder] = useState<string | null>(null);
    const [selectedTag, setSelectedTag] = useState<string | null>(null);
    const [searchQuery, setSearchQuery] = useState('');

    const supabase = getSupabase();

    const mapDocument = (record: DatabaseFileRecord): PDFDocumentMetadata => ({
        id: record.id,
        name: record.name,
        size: record.size,
        uploadedAt: new Date(record.created_at),
        storagePath: record.storage_path,
        thumbnailData: record.thumbnail_base64,
        summary: record.summary,
        folderId: record.folder_id,
        aiCategory: record.ai_category,
        tags: [],
    });

    const mapFolder = (record: DatabaseFolder): Folder => ({
        id: record.id,
        name: record.name,
        color: record.color,
        parentId: record.parent_id,
        userId: record.user_id,
        createdAt: new Date(record.created_at),
        fileCount: 0,
    });

    const mapTag = (record: DatabaseTag): Tag => ({
        id: record.id,
        name: record.name,
        color: record.color,
        userId: record.user_id,
        createdAt: new Date(record.created_at),
        fileCount: 0,
        isAutoGenerated: record.is_auto_generated,
    });

    const fetchData = useCallback(async () => {
        setIsLoading(true);
        setError(null);

        try {
            // Fetch documents
            let documentsQuery = supabase
                .from('files')
                .select('*')
                .order('created_at', { ascending: false });

            if (selectedFolder) {
                documentsQuery = documentsQuery.eq('folder_id', selectedFolder);
            }

            if (searchQuery) {
                documentsQuery = documentsQuery.ilike('name', `%${searchQuery}%`);
            }

            const [docsResult, foldersResult, tagsResult] = await Promise.all([
                documentsQuery,
                supabase.from('folders').select('*').order('name'),
                supabase.from('tags').select('*').order('name'),
            ]);

            if (docsResult.error) throw docsResult.error;
            if (foldersResult.error) throw foldersResult.error;
            if (tagsResult.error) throw tagsResult.error;

            setDocuments((docsResult.data || []).map(mapDocument));
            setFolders((foldersResult.data || []).map(mapFolder));
            setTags((tagsResult.data || []).map(mapTag));
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to fetch documents');
        } finally {
            setIsLoading(false);
        }
    }, [supabase, selectedFolder, searchQuery]);

    useEffect(() => {
        fetchData();
    }, [fetchData]);

    return {
        documents,
        folders,
        tags,
        isLoading,
        error,
        selectedFolder,
        selectedTag,
        searchQuery,
        setSelectedFolder,
        setSelectedTag,
        setSearchQuery,
        refresh: fetchData,
    };
}
